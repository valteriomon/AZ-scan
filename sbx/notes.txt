for file in sorted(os.listdir(args.input_dir)):
    full_path = os.path.join(args.input_dir, file)
    if os.path.isfile(full_path) and file.lower().endswith(('.jpg', '.jpeg', '.png', '.tif', '.tiff')):
        input_files.append(full_path)


add decorator to generate windows pto
move file logic out of pto_gen
check all filename basename extractions are done for win and linux paths
    fix folder_path

Command completed successfully.
Running pto_var with args: []
Running command: wsl pto_var -o ['--set', 'y0=-5.0,p0=7.5,r0=0'] None_pto.tmp
pto_var: no variables to modify given
Command failed with return code 1
Output: None

cache? cleanup



set scanner in options

# else:
#     if event.delta > 0:
#         self.rotate_at(90, event.x, event.y)  # Rotate clockwise
#     else:
#         self.rotate_at(-90, event.x, event.y)  # Rotate counter-clockwise

    # def rotate(self, deg:float):
    #     mat = np.eye(3)
    #     mat[0, 0] = math.cos(math.pi * deg / 180)
    #     mat[1, 0] = math.sin(math.pi * deg / 180)
    #     mat[0, 1] = -mat[1, 0]
    #     mat[1, 1] = mat[0, 0]

    #     self.mat_affine = np.dot(mat, self.mat_affine)

    # def rotate_at(self, deg:float, cx:float, cy:float):
    #     self.translate(-cx, -cy)
    #     self.rotate(deg)
    #     self.translate(cx, cy)


class EditorMode(tk.Frame):
    def __init__(self, master, canvas, on_rotate_callback):
        super().__init__(master)
        self.canvas = canvas
        self.on_rotate_callback = on_rotate_callback

        self.rotate_button = tk.Button(self, text="Rotate", command=self.on_rotate)
        self.rotate_button.pack(side=tk.LEFT)

    def on_rotate(self):
        self.on_rotate_callback()

        # if self.editor_enabled:
        #     self._create_editor_mode()


    # def rotate_image(self, angle):
    #     """Rotate image and refresh canvas"""
    #     if self.pil_image:
    #         self.pil_image = self.pil_image.rotate(90, expand=True)
    #         self._draw_image(self.pil_image)

    # def rotate_image(self, angle):
    #     if self.pil_image:
    #         if angle == 90 or angle == -90:
    #             self.rotation_angle = (self.rotation_angle + angle) % 360  # Reset to 90-degree increments
    #         else:
    #             self.rotation_angle += angle

    #         self.rotation_angle %= 360  # Ensure rotation stays within 0-360 degrees
    #         # self.image_stack.append(self.image.copy())  # Save the previous state
    #         self.pil_image = self.pil_image.rotate(self.rotation_angle, expand=True)  # Rotate the original image
    #         self.update_display_image()
    #         self.update_rotation_label()



    # def _create_editor_mode(self):
    #     """Creates and enables the editor mode, including a top bar."""
    #     self.editor_mode_frame = tk.Frame(self)
    #     self.editor_mode_frame.pack(side=tk.TOP, fill=tk.X)

    #     # Create Editor buttons
    #     self.editor_mode = EditorMode(self.editor_mode_frame, self.canvas, self.rotate_image)
    #     self.editor_mode.pack(side=tk.LEFT)





        # frame_editor_bar = tk.Frame(self)
        # tk.Button(frame_editor_bar, text="⟲", command=lambda: self.rotate_image(90)).pack(side="left")   # Counterclockwise
        # tk.Button(frame_editor_bar, text="⟳", command=lambda: self.rotate_image(-90)).pack(side="left")  # Clockwise

    #     # self.label_image_infoa = tk.Label(frame_editorbar, anchor=tk.E, padx=5)
    #     # self.label_image_infoa.pack(side=tk.RIGHT)
        # frame_editor_bar.pack(side=tk.TOP, fill=tk.X)


        if self.editor_enabled:
            self._enable_image_editor(self.canvas)


                def _enable_image_editor(self, canvas):
        def launch_editor(filepath):
            print(f"Launching editor for {filepath}")

        def show_context_menu(event):
            try:
                self.context_menu.tk_popup(event.x_root, event.y_root)
            finally:
                self.context_menu.grab_release()

        # Context menu
        self.context_menu = tk.Menu(self.canvas, tearoff=0)
        self.context_menu.add_command(label="Editar", command=lambda: launch_editor(self.filepath.get()))

        canvas.bind("<Button-3>", show_context_menu)
        canvas.bind("<Key-e>", lambda event: launch_editor(self.filepath.get()))
        canvas.focus_set()




SET MIN WINDOW WIDTH













import os
import tkinter as tk
from PIL import Image, ImageTk
import numpy as np
import cv2
from core.constants import APP_TITLE, VIEWER_VIEW_TITLE

class ImageViewer(tk.Frame):

    def __init__(self, master, filepath, status_bar_enabled=True, editor_enabled=True):
        super().__init__(master)
        self.filepath = tk.StringVar(value=filepath)
        self.editor_enabled = editor_enabled
        self.status_bar_enabled = status_bar_enabled or editor_enabled

        self.is_main_window = isinstance(master, (tk.Tk, tk.Toplevel))
        self.title = f"{APP_TITLE} - {VIEWER_VIEW_TITLE}"

        if self.is_main_window:
            master.geometry("800x600")
            master.geometry("-1200+200")
            master.title(self.title)
            try:
                master.iconbitmap("assets/images/logo32.ico")
            except Exception:
                pass

        self.pil_image = None
        self.cv_image = None  # OpenCV image
        self.is_edit_mode = False  # Track edit mode state
        self.hq_render_after_id = None

        self._create_canvas()
        self._reset_transform()

        if self.status_bar_enabled:
            self._create_status_bar()

        if self.editor_enabled:
            self._enable_image_editor(self.canvas)

        self.after(100, self.set_image)

        if self.is_main_window:
            self.pack(expand=True, fill=tk.BOTH)
            master.bind("<Configure>", self._on_resize)  # Bind to top-level ImageViewer.
        else:
            self.bind("<Configure>", self._on_resize)    # Bind to self when embedded.

    def set_image(self, filepath=None):
        if not filepath:
            filepath = self.filepath.get()

        self.pil_image = Image.open(filepath)
        self.filepath.set(filepath)
        self._zoom_fit(self.pil_image.width, self.pil_image.height)
        self._draw_image(self.pil_image)

        if self.is_main_window:
            filename = os.path.basename(filepath)
            self.master.title(f"{self.title} - {filename}")

    def _on_resize(self, event):
        if self.is_edit_mode and self.cv_image is not None:
            self._zoom_fit(self.cv_image.shape[1], self.cv_image.shape[0])  # Use OpenCV's width and height
        elif self.pil_image:
            self._zoom_fit(self.pil_image.width, self.pil_image.height)
        self._redraw_image()

    def _create_canvas(self):
        self.canvas = tk.Canvas(self, background="black", bd=0, highlightthickness=0)
        self.canvas.pack(expand=True, fill=tk.BOTH)

        # Bind to self.canvas for more consistent behavior across modes
        bind_target = self.canvas

        bind_target.bind("<Button-1>", self._mouse_down_left)
        bind_target.bind("<B1-Motion>", self._mouse_move_left)
        bind_target.bind("<Double-Button-1>", self._mouse_double_click_left)
        bind_target.bind("<MouseWheel>", self._mouse_wheel)

        # Escape key should still go to top-level window
        if self.is_main_window:
            self.master.bind("<Escape>", self._menu_quit_clicked)

    def _create_status_bar(self):
        frame_statusbar = tk.Frame(self)

        self.label_filepath = tk.Label(frame_statusbar, anchor=tk.W, padx=5)
        self.label_filepath.pack(side=tk.LEFT)

        self.label_image_info = tk.Label(frame_statusbar, anchor=tk.E, padx=5)
        self.label_image_info.pack(side=tk.RIGHT)

        frame_statusbar.pack(side=tk.BOTTOM, fill=tk.X)

        def update_status_bar(name=None, index=None, mode=None):
            self.label_filepath["text"]     = os.path.abspath(self.filepath.get())
            if self.is_edit_mode and self.cv_image is not None:
                self.label_image_info["text"] = f"OpenCV : {self.cv_image.shape[1]} x {self.cv_image.shape[0]}"
            else:
                self.label_image_info["text"] = f"{self.pil_image.format} : {self.pil_image.width} x {self.pil_image.height} {self.pil_image.mode}"

        self.filepath.trace_add("write", update_status_bar)

    def _enable_image_editor(self, canvas):
        def launch_editor(filepath):
            print(f"Launching editor for {filepath}")
            # Toggle edit mode
            if self.is_edit_mode:
                # Exit edit mode: Reload the Pillow image
                self.is_edit_mode = False
                self.cv_image = None
                self.set_image(filepath)
            else:
                # Enter edit mode: Switch to OpenCV image
                self.is_edit_mode = True
                self.cv_image = cv2.imread(filepath)
                self._zoom_fit(self.cv_image.shape[1], self.cv_image.shape[0])
                self._draw_opencv_image(self.cv_image)

        def show_context_menu(event):
            try:
                self.context_menu.tk_popup(event.x_root, event.y_root)
            finally:
                self.context_menu.grab_release()

        # Context menu
        self.context_menu = tk.Menu(self.canvas, tearoff=0)
        self.context_menu.add_command(label="Editar", command=lambda: launch_editor(self.filepath.get()))
        canvas.bind("<Button-3>", show_context_menu)
        canvas.bind("<Key-e>", lambda event: launch_editor(self.filepath.get()))
        canvas.focus_set()

    """
    Event handlers
    """
    def _menu_quit_clicked(self, event):
        self.master.destroy()
        return "break"

    def _mouse_down_left(self, event):
        self.__old_event = event

    def _mouse_move_left(self, event):
        if self.pil_image == None:
            return
        self._translate(event.x - self.__old_event.x, event.y - self.__old_event.y)
        self._redraw_image()
        self.__old_event = event

    def _mouse_double_click_left(self, event):
        if self.pil_image == None:
            return
        if self.zoom_level or not self.centered:
            self._zoom_fit(self.pil_image.width, self.pil_image.height)
            self._redraw_image()

    def _mouse_wheel(self, event):
        if self.pil_image is None:
            return

        if event.state != 9:
            if event.delta > 0:
                self.zoom_level += 1
                self._scale_at(1.25, event.x, event.y)  # Zoom in
            elif self.zoom_level > 0:
                self._scale_at(0.8, event.x, event.y)  # Zoom out
                self.zoom_level -= 1
            elif self.zoom_level == 0 and not self.centered:
                self._zoom_fit(self.pil_image.width, self.pil_image.height)
            else:
                return
            self._redraw_image()

    """
    Transformations
    """
    def _reset_transform(self):
        self.mat_affine = np.eye(3)

    def _translate(self, offset_x, offset_y):
        self.centered = False
        mat = np.eye(3)
        mat[0, 2] = float(offset_x)
        mat[1, 2] = float(offset_y)
        self.mat_affine = np.dot(mat, self.mat_affine)

    def _scale(self, scale:float):
        mat = np.eye(3)
        mat[0, 0] = scale
        mat[1, 1] = scale
        self.mat_affine = np.dot(mat, self.mat_affine)

    def _scale_at(self, scale:float, cx:float, cy:float):
        self._translate(-cx, -cy)
        self._scale(scale)
        self._translate(cx, cy)

    def _zoom_fit(self, image_width, image_height):
        canvas_width = self.canvas.winfo_width()
        canvas_height = self.canvas.winfo_height()

        if (image_width * image_height <= 0) or (canvas_width * canvas_height <= 0):
            return
        self._reset_transform()

        scale, offsetx, offsety = self._compute_scale_and_offset(canvas_width, canvas_height, image_width, image_height)

        self._scale(scale)
        self._translate(offsetx, offsety)

        self.zoom_level = 0
        self.centered = True

    def _compute_scale_and_offset(self, canvas_width, canvas_height, image_width, image_height):
        scale = 1.0
        offsetx = 0.0
        offsety = 0.0

        if (canvas_width * image_height) > (image_width * canvas_height):
            scale = canvas_height / image_height
            offsetx = (canvas_width - image_width * scale) / 2
        else:
            scale = canvas_width / image_width
            offsety = (canvas_height - image_height * scale) / 2

        return scale, offsetx, offsety

    def _draw_opencv_image(self, cv_image):
        """Draw OpenCV image (in BGR) to the canvas."""
        cv_image_rgb = cv2.cvtColor(cv_image, cv2.COLOR_BGR2RGB)
        pil_image = Image.fromarray(cv_image_rgb)
        self._draw_image(pil_image)

    def _draw_image(self, pil_image, resample=Image.NEAREST):
        if pil_image is None:
            return

        self.pil_image = pil_image
        canvas_width = self.canvas.winfo_width()
        canvas_height = self.canvas.winfo_height()

        mat_inv = np.linalg.inv(self.mat_affine)
        affine_inv = (
            mat_inv[0, 0], mat_inv[0, 1], mat_inv[0, 2],
            mat_inv[1, 0], mat_inv[1, 1], mat_inv[1, 2]
        )
        dst = self.pil_image.transform(
            (canvas_width, canvas_height),
            Image.AFFINE,
            affine_inv,
            resample
        )

        im = ImageTk.PhotoImage(image=dst)
        self.canvas.delete("all")  # Clear previous image
        self.canvas.create_image(0, 0, anchor='nw', image=im)
        self.image = im

    def _redraw_image(self):
        if self.pil_image is None:
            return

        # Fast redraw with NEAREST
        self._draw_image(self.pil_image, resample=Image.NEAREST)

        # Cancel any previously scheduled high-quality redraw
        if self.hq_render_after_id:
            self.after_cancel(self.hq_render_after_id)

        # Schedule a high-quality redraw after 300 ms
        self.hq_render_after_id = self.after(300, lambda: self._draw_image(self.pil_image, resample=Image.BICUBIC))

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Simple responsive image viewer.")
    parser.add_argument("image", help="Path to the image file.")
    args = parser.parse_args()

    root = tk.Tk()
    app = ImageViewer(master=root, filepath=args.image)

    app.mainloop()

































def toggle_dark_mode():
    global dark_mode
    dark_mode = not dark_mode
    # apply_theme()

def setup_menu(root):
    menubar = tk.Menu(root)
    view_menu = tk.Menu(menubar, tearoff=0)
    view_menu.add_command(label="Cambiar tema", command=toggle_dark_mode)
    menubar.add_cascade(label="Opciones", menu=view_menu)
    root.config(menu=menubar)







    def apply_theme():
    global style, dark_mode
    if not style:
        style = ttk.Style()

    if dark_mode:
        root_bg = button_bg = "#dddddd"
        fg = "#e8e8e8"
    else:
        root_bg = button_bg = "#f0f0f0"
        fg = "green"

    style.configure("TFrame", background=root_bg)
    style.configure("TLabel", background=root_bg, foreground=fg)
    style.configure("TButton", bg=button_bg, foreground=fg)
    style.configure("Big.TButton", font=BIG_FONT, padding=10, background=button_bg, foreground=fg)
    style.map("Big.TButton",
        background=[("active", "green"), ("!active", "blue")],
        foreground=[
            ("active", "white"),
            ("!active", "black"),
            ("pressed", "black"),
            ("!pressed", "black"),
            ("active", "red")],
        relief=[("pressed", "flat"), ("!pressed", "flat")]
    )















        # answer = self.ask_yes_no("Delete", "Do you want to delete this file?")
        # if answer:
        #     print("User chose Yes")
        # else:
        #     print("User chose No")
            # @staticmethod
    #     def show_about(event: tkinter.Event):
    #         messagebox.showinfo("About",
    #                             '''º''')




        # path = filepath  # Or self.app_state.next_filepath
        # try:
        #     image = Image.open(path)

        #     # Resize image to fit the window
        #     aspect_ratio = image.width / image.height
        #     new_height = 600
        #     new_width = int(new_height * aspect_ratio)

        #     max_size = (800, 600)
        #     # image.thumbnail(max_size, Image.Resampling.LANCZOS)
        #     image = image.resize((new_width, new_height), Image.Resampling.LANCZOS)

        #     self.tk_image = ImageTk.PhotoImage(image)
        #     self.preview_image.config(image=self.tk_image)
        #     if not hasattr(self, "_minsize"):
        #         self._minsize = (0, 0)

        #     self.root.update_idletasks()
        #     w, h = self.root.winfo_width(), self.root.winfo_height()
        #     w = max(w, self._minsize[0])
        #     h = max(h, self._minsize[1])
        #     self._minsize = (w, h)
        #     self.root.minsize(w, h)

        #     # self.preview_image.image = self.tk_image  # Prevent garbage collection
        # except FileNotFoundError:
        #     self.preview_image.config(text="File not found.")
        # except Exception as e:
        #     self.preview_image.config(text=f"Error: {e}", foreground="red")









Load Images. Type 10 in HFOV
in the Images tab, select all of them and do Feature Matching, Settings: Hugins's CPFind, Points per Overlap: Doesnt Matter with CPFind, it uses a different Algorithm to spread the Control Points
turn the images with roll in 90° steps so the are the right way up
in the Control Points tab, select the same image on both sides (it needs to have a visible border), then set a cp on one end of the border and the corresponding point in the other view on the other end of the boarder, click fine tune (or press f)
in the Optimizer Tab, optimize "the Custum parameters below": deselect everything, then select roll for everything, X, Y and view(v) for everything but the first Image.
in the Image Tab, select all Images, then Cean control points
optimize again  with the same settings
select Projection Rectilinear, calc FOV, calc optimal size, fit to crop images
click stitch

--
Seems to work if I do a pass with --linearmatch first,  and a second pass with  --prealigned. Thanks so much @GnomeNomad!

I set one of the central images as anchor by right clicking in the image and choosing Anchor this image for position/exposure, then proceed to right click on every image except the first one and choose Lens > New lens. I also go in Optimise > Geometric and choose Custom parameters;
Switch to the Control points tab and let Hugin's engine (default Hugin's CPFind) detect control points between pairs of images. I also make sure that every image has CPs with images overlapping from top/bottom, left/right and angles (is this necessary or overkill?). After every run of CPFind, I check for false positives, a quick way is to compare the distances of every cp, in my case they all match except the false positives;
In the Optimiser tab, I unselect all Yaw, Pitch and Roll, and select all X and Y (the anchor has nothing active). Under Lens Parameters I select all Hvof (v). Then click on Optimise now! and apply the changes;
Open the Preview panorama window and choose Straighten, you should be able to see the stitched image at this point;
Open the Stitcher tab, click on Calculate Optimal Size and Fit Crop to Images, eventually choose your format and other settings, and Stitch!

Still in the Photos tab we go to Optimize, and for this project we use Mosaic mode, in the Geometric: menu select Custom parameters then select the Optimizer tab. Use the left mouse to on Yaw(y) and Pitch(p) and Unselect all, then Select all on X(TrX), Y(TrY), and Z(TrZ).
Note, that an alternate approach is to optimize by setting r,v,d,e for all images other than the anchor, which would have only Roll (r) selected in Image orientation and Hfov (v),d,e selected in Lens parameters

When it is done you will need to select the Optimize now! button. Now is a good time to use the Fast Panorama preview window to check that everything is going to be OK.

Select Projection and set to rectilinear, then drag the window sliders to set suitable fields of view.
Select Move/Drag to position the image using Mosaic mode, and then select Crop and drag the inside of the cropping rectangle to adjust the crop.
That's it...you can now use the Stitcher tab to create a permanent output file as usual.
In the Stitcher tab select Calculate Optimal Size, set your outputs and then Stitch Now...
We have used Calculate Optimal Size for this example because the images have been scanned from printed material and the optimal size will minimize any pattern effects that might occur if the resulting stitch is scaled down.

You could try loading your images and then using the Move/Drag tab in the
Fast Panorama preview window, to roughly position your images, then use
CPfind (prealigned) to find control points.
If you are using the new gui, you might try doing this using the Advanced
interface, and select CPFind(prealigned) from the "Feature Matching
Settings:" menu, which will save you altering your preferences. That
general approach should also be available in the old gui.
Lets's know if that helps.

Terry, thanks for the help on this.  Under the Photos tab using the Advanced Interface I was able to find the Settings under Feature Matching but done of the options was CPfind (pre aligned).  However if I select all my images, using cpfind and hit Create control points then it looks like it uses the default I set in preferences and only gives control points between the adjacent pairs (it worked with or without pre aligning the images).  So it appears that if you use Align… on the Assistant tab then it does its own thing about finding control points and doesn't use what is in the Preferences.  Is this a bug? (or a feature?  ;o)  )

After that I also had to select Vertical Lines for the Settings under Feature Matching.  At this point switching back to the Fast Panorama preview window and the pano wasn't lined up yet.  I switched back to the Panorama Stitcher window and did a Calculate for the Geometric Optimize! Then in the preview window I was able to do all the move/drag and crop.

I had only ever used the move/drag after a stitch so wasn't aware you could use it before on the individual images.  Thanks again.

#!/bin/bash

pto_gen -o scripting_step1_images.pto IMG_*.JPG

# https://wiki.panotools.org/Panorama_scripting_in_a_nutshell

# https://groups.google.com/g/hugin-ptx/c/ImcaDTH7KMY/m/GcHI-wNnFAAJ
# https://wiki.panotools.org/Pto_var
# simplified layout asuming 360° panorama
# rows are not needed in calculation, it's assumed that rows = number of pictures / columns
columns=8
degrees_below_horizon=55 # how far below the horizon does the panorama start?
field_of_view_horizontal=$((360/$columns)) # not the real field_of_view, subtract half of the overlap..
echo "field_of_view_horizontal = $field_of_view_horizontal"
field_of_view_vertical=$(($field_of_view_horizontal/4*3))
pto_var --set="y=(i%$columns)*$field_of_view_horizontal,p=floor(i/$columns)*$field_of_view_vertical-$degrees_below_horizon,r=0" --output=scripting_step2_align_rows_and_columns.pto scripting_step1_images.pto

pto_mask --process=CLIP --mask=mask.msk@0 --mask=mask.msk@1 --mask=mask.msk@2 --mask=mask.msk@3 --mask=mask.msk@4 --mask=mask.msk@5 --mask=mask.msk@6 --mask=mask.msk@7 --output=scripting_step3_masks.pto scripting_step2_align_rows_and_columns.pto

# https://wiki.panotools.org/Cpfind
# --multirow --sieve2width=10 --sieve2height=10 --sieve2size=20 --minmatches=1
cpfind --verbose --prealigned --fullscale --cache --output=scripting_step4_prealigned_cpfind.pto scripting_step3_masks.pto

linefind --output=scripting_step5_vertical-lines.pto scripting_step4_prealigned_cpfind.pto

# https://wiki.panotools.org/Geocpset
geocpset --each-overlap --output=scripting_step6_geocpset.pto scripting_step5_vertical-lines.pto

autooptimiser -a -m --output=scripting_step7_autoptimized.pto scripting_step6_geocpset.pto

hugin scripting_step7_autoptimized.pto


Thomas reminded me that Hugin already has a method for adding
control-points to pre-aligned panoramas, something that is regularly
requested here.
i.e. you can load photos, approximately line them up by dragging
them around in the preview, and run a control-point detection that
only tries to match photos that overlap in the preview.

This is also the ideal way of stitching from a template. If you
always shoot the same arrangement, you can save this layout as a
template, then for each new project load the template, and only
match the pairs of photos that you know need matching.

Another technique would be script creation of the template, e.g. if
you have a complex layout, or shoot with a robotic head that has
logging you can then control the whole process.

To do this you need to add a New Control Point Detector in File ->
Preferences, call it something like 'Prealigned CPFind'. With the
Type set to 'Prealigned panorama', set Detector to 'One step
detector', Program to 'cpfind', Arguments to '-o %o %s', and make
sure the Advanced option is set to 'Only work on image pairs without
control points'.

Choose this whenever you do feature matching and Hugin will only
match the photos you tell it to match.

Once you have this setup in the Hugin GUI, you can also use this
setting with the 'icpfind' command-line tool.




I want to add: Alternatively you could use:
argument: '--cache -o %o %s'
cleanup argument: '--cleanup %s'

This will cache the keypoints to disc, so keypoints are only searched
once per image. (The keyfiles are delete at the end with the cleanup
argument.)
This should run a bit faster than the above setting.

Should I try and add this configuration to the default set of
control point generators in Hugin? It seems like a good option to
have.

On the question of generating a layout template for a robotic head or
similarly systematic set of images, wouldn't it be convenient to be
able to edit the "image lines" section of the PTO as a spreadsheet ?

I tried this:
1. open a pto file in a text editor
2. copy the "image lines" section
3. paste into your spreadsheet app (I used openoffice calc)
4. in the format conversion dialogue, choose "character space" as the
column seperator
5. edit the relevant parameter(s) by selecting the relevant column and
every other row (this is a bit tricky because you need to preserve /
rebuild the table structure)
6. copy all and paste into a text editor
7. search and replace to convert the tab seperator to a char space
8. copy and paste into your PTO template, and save.

I couldn't help but think it would be a nice feature if Hugin could
simply export and import particular parts of the PTO as a CSV file.
That would make life much easier :-)















        self.grid_frame = tk.Frame(root)
        self.grid_frame.pack(padx=20, pady=20)

        self.buttons = {}
        self.current_row = 0
        self.current_col = 0
        self.direction = 'right'
        self.max_col = None  # None means column limit isn't locked yet

        self.add_button(self.current_row, self.current_col)

    def add_button(self, row, col):
        if (row, col) not in self.buttons:
            btn = tk.Button(
                self.grid_frame,
                text=f"{row},{col}",
                command=lambda r=row, c=col: self.on_button_click(r, c)
            )
            btn.grid(row=row, column=col, padx=5, pady=5)
            self.buttons[(row, col)] = btn

    def on_button_click(self, row, col):
        if row != self.current_row or col != self.current_col:
            return  # Only allow clicks on the current endpoint button

        if self.max_col is None:
            # Still building first row freely to the right
            self.current_col += 1
            self.add_button(self.current_row, self.current_col)
        else:
            if self.direction == 'right':
                if self.current_col < self.max_col:
                    self.current_col += 1
                    self.add_button(self.current_row, self.current_col)
                else:
                    self.current_row += 1
                    self.add_button(self.current_row, self.current_col)
                    self.direction = 'left'
            else:  # direction == 'left'
                if self.current_col > 0:
                    self.current_col -= 1
                    self.add_button(self.current_row, self.current_col)
                else:
                    self.current_row += 1
                    self.add_button(self.current_row, self.current_col)
                    self.direction = 'right'

        # If we’ve gone down for the first time, lock max_col
        if self.max_col is None and self.current_row > 0:
            self.max_col = self.current_col

        self.canvas_size = 800
        self.square_size = 50
        self.offset = self.canvas_size // 2

        self.canvas = tk.Canvas(root, width=self.canvas_size, height=self.canvas_size, bg='white')
        self.canvas.pack()

        self.positions = set()
        self.min_x = self.max_x = 0
        self.min_y = self.max_y = 0

        self.draw_square(0, 0)
        self.draw_arrows()

    def grid_to_canvas(self, x, y):
        """Convert grid coords to canvas pixel coords (top-left)."""
        left = self.offset + x * self.square_size
        top = self.offset + y * self.square_size
        return left, top

    def draw_square(self, x, y):
        left, top = self.grid_to_canvas(x, y)
        right = left + self.square_size
        bottom = top + self.square_size
        self.canvas.create_rectangle(left, top, right, bottom, fill='skyblue', outline='black')
        self.positions.add((x, y))
        self.min_x = min(self.min_x, x)
        self.max_x = max(self.max_x, x)
        self.min_y = min(self.min_y, y)
        self.max_y = max(self.max_y, y)

    def draw_arrows(self):
        # Remove old arrows
        for tag in self.canvas.find_withtag("arrow"):
            self.canvas.delete(tag)

        # Horizontal expansion arrows (top and bottom)
        for x in range(self.min_x, self.max_x + 1):
            if (x, self.min_y - 1) not in self.positions:
                self.create_arrow_button("↑", x, self.min_y - 1, 0, -1)
            if (x, self.max_y + 1) not in self.positions:
                self.create_arrow_button("↓", x, self.max_y + 1, 0, 1)

        # Vertical expansion arrows (left and right)
        for y in range(self.min_y, self.max_y + 1):
            if (self.min_x - 1, y) not in self.positions:
                self.create_arrow_button("←", self.min_x - 1, y, -1, 0)
            if (self.max_x + 1, y) not in self.positions:
                self.create_arrow_button("→", self.max_x + 1, y, 1, 0)

    def create_arrow_button(self, symbol, grid_x, grid_y, dx, dy):
        """Create a styled arrow button at the specified grid position."""
        bx, by = self.grid_to_canvas(grid_x, grid_y)
        button = tk.Button(
            self.root, text=symbol,
            font=("Arial", 14, "bold"),
            width=2, height=1,
            bg="lightgray", relief="raised",
            command=lambda: self.add_square(grid_x, grid_y)
        )
        self.canvas.create_window(
            bx + self.square_size // 2,
            by + self.square_size // 2,
            window=button,
            tags="arrow"
        )

    def add_square(self, x, y):
        if (x, y) not in self.positions:
            self.draw_square(x, y)
            self.draw_arrows()




        self.clicked_color = "lightblue"
        self.default_color = "SystemButtonFace"
        self.grid = {}  # {(row, col): button}
        self.image_cache = {}  # Prevent garbage collection

        self.image_path = os.path.join(os.path.dirname(__file__), "test.png")
        self.button_pixel_size = (100, 100)

        # History of full states
        self.history = []

        # Control panel
        self.control_frame = tk.Frame(root)
        self.control_frame.pack(pady=5)

        self.reset_button = tk.Button(self.control_frame, text="Reset", command=self.reset_grid)
        self.reset_button.pack(side=tk.LEFT, padx=5)

        self.undo_button = tk.Button(self.control_frame, text="Undo", command=self.undo)
        self.undo_button.pack(side=tk.LEFT, padx=5)

        tk.Label(self.control_frame, text="Rows:").pack(side=tk.LEFT)
        self.rows_entry = tk.Entry(self.control_frame, width=5)
        self.rows_entry.pack(side=tk.LEFT, padx=2)

        tk.Label(self.control_frame, text="Cols:").pack(side=tk.LEFT)
        self.cols_entry = tk.Entry(self.control_frame, width=5)
        self.cols_entry.pack(side=tk.LEFT, padx=2)

        self.set_button = tk.Button(self.control_frame, text="Set Size", command=self.set_size)
        self.set_button.pack(side=tk.LEFT, padx=5)

        # Grid container
        self.grid_frame = tk.Frame(root)
        self.grid_frame.pack(pady=5)

        self.min_row = self.min_col = -1
        self.max_row = self.max_col = 1

        self.render_grid()

    def render_grid(self):
        for row in range(self.min_row, self.max_row + 1):
            for col in range(self.min_col, self.max_col + 1):
                if (row, col) not in self.grid:
                    btn = tk.Button(self.grid_frame,
                                    command=lambda r=row, c=col: self.on_click(r, c))
                    btn.config(width=self.button_pixel_size[0] // 7,
                               height=self.button_pixel_size[1] // 15)
                    self.grid[(row, col)] = btn

        self.update_layout()

    def update_layout(self):
        for widget in self.grid_frame.winfo_children():
            widget.grid_forget()

        rows = self.max_row - self.min_row + 1
        cols = self.max_col - self.min_col + 1

        for r in range(rows):
            self.grid_frame.rowconfigure(r, weight=1)
        for c in range(cols):
            self.grid_frame.columnconfigure(c, weight=1)

        for (r, c), btn in self.grid.items():
            grid_r = r - self.min_row
            grid_c = c - self.min_col
            btn.grid(row=grid_r, column=grid_c, padx=2, pady=2, sticky="nsew")

    def on_click(self, row, col):
        self.save_state()

        btn = self.grid[(row, col)]
        btn.config(bg=self.clicked_color)

        # Load and resize image to fixed pixel size
        if os.path.exists(self.image_path):
            width, height = self.button_pixel_size
            img = Image.open(self.image_path)
            img = img.resize((width, height), Image.Resampling.LANCZOS)
            tk_img = ImageTk.PhotoImage(img)
            self.image_cache[(row, col)] = tk_img
            btn.config(image=tk_img, compound="center", text="")

        # Determine if expansion is needed
        rows = list(range(self.min_row, self.max_row + 1))
        cols = list(range(self.min_col, self.max_col + 1))
        center_row = rows[len(rows) // 2]
        center_col = cols[len(cols) // 2]

        changed = False
        if row == self.min_row:
            self.min_row -= 1
            changed = True
        if row == self.max_row:
            self.max_row += 1
            changed = True
        if col == self.min_col:
            self.min_col -= 1
            changed = True
        if col == self.max_col:
            self.max_col += 1
            changed = True

        if changed:
            self.render_grid()

    def save_state(self):
        # Save current full state
        state = {
            'min_row': self.min_row,
            'max_row': self.max_row,
            'min_col': self.min_col,
            'max_col': self.max_col,
            'button_states': {},
        }

        for (row, col), btn in self.grid.items():
            state['button_states'][(row, col)] = {
                'bg': btn.cget('bg'),
                'image': self.image_cache.get((row, col), None)
            }

        # Deepcopy the image cache refs
        state['image_cache'] = dict(self.image_cache)
        self.history.append(state)

    def restore_state(self, state):
        # Destroy all current buttons
        for btn in self.grid.values():
            btn.destroy()

        self.grid.clear()
        self.image_cache.clear()

        self.min_row = state['min_row']
        self.max_row = state['max_row']
        self.min_col = state['min_col']
        self.max_col = state['max_col']
        self.image_cache = dict(state['image_cache'])

        for (row, col), data in state['button_states'].items():
            btn = tk.Button(self.grid_frame,
                            command=lambda r=row, c=col: self.on_click(r, c))
            btn.config(width=self.button_pixel_size[0] // 7,
                       height=self.button_pixel_size[1] // 15,
                       bg=data['bg'])
            if data['image']:
                btn.config(image=data['image'], compound="center", text="")
            self.grid[(row, col)] = btn

        self.update_layout()

    def undo(self):
        if not self.history:
            return
        last_state = self.history.pop()
        self.restore_state(last_state)

    def reset_grid(self):
        for btn in self.grid.values():
            btn.destroy()
        self.grid.clear()
        self.image_cache.clear()
        self.history.clear()

        self.min_row = self.min_col = -1
        self.max_row = self.max_col = 1

        self.render_grid()

    def set_size(self):
        try:
            rows = int(self.rows_entry.get())
            cols = int(self.cols_entry.get())
            if rows < 1 or cols < 1:
                raise ValueError

            self.history.clear()
            half_r = rows // 2
            half_c = cols // 2
            self.min_row = -half_r
            self.max_row = self.min_row + rows - 1
            self.min_col = -half_c
            self.max_col = self.min_col + cols - 1

            for btn in self.grid.values():
                btn.destroy()
            self.grid.clear()
            self.image_cache.clear()
            self.render_grid()
        except ValueError:
            messagebox.showerror("Invalid input", "Please enter positive integers for rows and columns.")











        self.clicked_color = "lightblue"
        self.default_color = "SystemButtonFace"
        self.grid = {}  # {(row, col): button}
        self.image_cache = {}  # Prevent garbage collection

        self.image_path = os.path.join(os.path.dirname(__file__), "test.png")
        self.button_pixel_size = (100, 100)

        # History of full states
        self.history = []

        # Control panel
        self.control_frame = tk.Frame(root)
        self.control_frame.pack(pady=5)

        self.reset_button = tk.Button(self.control_frame, text="Reset", command=self.reset_grid)
        self.reset_button.pack(side=tk.LEFT, padx=5)

        self.undo_button = tk.Button(self.control_frame, text="Undo", command=self.undo)
        self.undo_button.pack(side=tk.LEFT, padx=5)

        tk.Label(self.control_frame, text="Rows:").pack(side=tk.LEFT)
        self.rows_entry = tk.Entry(self.control_frame, width=5)
        self.rows_entry.pack(side=tk.LEFT, padx=2)

        tk.Label(self.control_frame, text="Cols:").pack(side=tk.LEFT)
        self.cols_entry = tk.Entry(self.control_frame, width=5)
        self.cols_entry.pack(side=tk.LEFT, padx=2)

        self.set_button = tk.Button(self.control_frame, text="Set Size", command=self.set_size)
        self.set_button.pack(side=tk.LEFT, padx=5)

        # Grid container
        self.grid_frame = tk.Frame(root)
        self.grid_frame.pack(pady=5)

        self.min_row = self.min_col = -1
        self.max_row = self.max_col = 1

        # Flag to track the first click
        self.first_click = True

        self.render_grid()

    def render_grid(self):
        for row in range(self.min_row, self.max_row + 1):
            for col in range(self.min_col, self.max_col + 1):
                if (row, col) not in self.grid:
                    btn = tk.Button(self.grid_frame,
                                    command=lambda r=row, c=col: self.on_click(r, c))
                    btn.config(width=self.button_pixel_size[0] // 7,
                               height=self.button_pixel_size[1] // 15)
                    if self.first_click:
                        if row != 0 or col != 0:
                            btn.config(state=tk.DISABLED)  # Disable all buttons except the center one
                    self.grid[(row, col)] = btn

        self.update_layout()

    def update_layout(self):
        for widget in self.grid_frame.winfo_children():
            widget.grid_forget()

        rows = self.max_row - self.min_row + 1
        cols = self.max_col - self.min_col + 1

        for r in range(rows):
            self.grid_frame.rowconfigure(r, weight=1)
        for c in range(cols):
            self.grid_frame.columnconfigure(c, weight=1)

        for (r, c), btn in self.grid.items():
            grid_r = r - self.min_row
            grid_c = c - self.min_col
            btn.grid(row=grid_r, column=grid_c, padx=2, pady=2, sticky="nsew")

    def on_click(self, row, col):
        if self.first_click:
            self.first_click = False
            # After the first click, enable all buttons again
            for btn in self.grid.values():
                btn.config(state=tk.NORMAL)

        self.save_state()

        btn = self.grid[(row, col)]
        btn.config(bg=self.clicked_color)

        # Load and resize image to fixed pixel size
        if os.path.exists(self.image_path):
            width, height = self.button_pixel_size
            img = Image.open(self.image_path)
            img = img.resize((width, height), Image.Resampling.LANCZOS)
            tk_img = ImageTk.PhotoImage(img)
            self.image_cache[(row, col)] = tk_img
            btn.config(image=tk_img, compound="center", text="")

        # Determine if expansion is needed
        rows = list(range(self.min_row, self.max_row + 1))
        cols = list(range(self.min_col, self.max_col + 1))
        center_row = rows[len(rows) // 2]
        center_col = cols[len(cols) // 2]

        changed = False
        if row == self.min_row:
            self.min_row -= 1
            changed = True
        if row == self.max_row:
            self.max_row += 1
            changed = True
        if col == self.min_col:
            self.min_col -= 1
            changed = True
        if col == self.max_col:
            self.max_col += 1
            changed = True

        if changed:
            self.render_grid()

    def save_state(self):
        # Save current full state
        state = {
            'min_row': self.min_row,
            'max_row': self.max_row,
            'min_col': self.min_col,
            'max_col': self.max_col,
            'button_states': {},
        }

        for (row, col), btn in self.grid.items():
            state['button_states'][(row, col)] = {
                'bg': btn.cget('bg'),
                'image': self.image_cache.get((row, col), None)
            }

        # Deepcopy the image cache refs
        state['image_cache'] = dict(self.image_cache)
        self.history.append(state)

    def restore_state(self, state):
        # Destroy all current buttons
        for btn in self.grid.values():
            btn.destroy()

        self.grid.clear()
        self.image_cache.clear()

        self.min_row = state['min_row']
        self.max_row = state['max_row']
        self.min_col = state['min_col']
        self.max_col = state['max_col']
        self.image_cache = dict(state['image_cache'])

        for (row, col), data in state['button_states'].items():
            btn = tk.Button(self.grid_frame,
                            command=lambda r=row, c=col: self.on_click(r, c))
            btn.config(width=self.button_pixel_size[0] // 7,
                       height=self.button_pixel_size[1] // 15,
                       bg=data['bg'])
            if data['image']:
                btn.config(image=data['image'], compound="center", text="")
            self.grid[(row, col)] = btn

        self.update_layout()

    def undo(self):
        if not self.history:
            return
        last_state = self.history.pop()
        self.restore_state(last_state)

    def reset_grid(self):
        for btn in self.grid.values():
            btn.destroy()
        self.grid.clear()
        self.image_cache.clear()
        self.history.clear()

        self.min_row = self.min_col = -1
        self.max_row = self.max_col = 1

        self.first_click = True  # Reset the first click flag
        self.render_grid()

    def set_size(self):
        try:
            rows = int(self.rows_entry.get())
            cols = int(self.cols_entry.get())
            if rows < 1 or cols < 1:
                raise ValueError

            self.history.clear()
            half_r = rows // 2
            half_c = cols // 2
            self.min_row = -half_r
            self.max_row = self.min_row + rows - 1
            self.min_col = -half_c
            self.max_col = self.min_col + cols - 1

            for btn in self.grid.values():
                btn.destroy()
            self.grid.clear()
            self.image_cache.clear()
            self.render_grid()
        except ValueError:
            messagebox.showerror("Invalid input", "Please enter positive integers for rows and columns.")












import tkinter as tk
from PIL import Image, ImageTk
import os

class Main:
    def __init__(self, root):
        self.clicked_color = "lightblue"
        self.default_color = "SystemButtonFace"
        self.grid = {}  # {(row, col): button}
        self.image_cache = {}  # Prevent garbage collection

        self.image_path = os.path.join(os.path.dirname(__file__), "test.png")
        self.button_pixel_size = (100, 100)

        # History of full states
        self.history = []

        # Control panel
        self.control_frame = tk.Frame(root)
        self.control_frame.pack(pady=5)

        self.reset_button = tk.Button(self.control_frame, text="Reset", command=self.reset_grid)
        self.reset_button.pack(side=tk.LEFT, padx=5)

        self.undo_button = tk.Button(self.control_frame, text="Undo", command=self.undo)
        self.undo_button.pack(side=tk.LEFT, padx=5)

        tk.Label(self.control_frame, text="Rows:").pack(side=tk.LEFT)
        self.rows_entry = tk.Entry(self.control_frame, width=5)
        self.rows_entry.pack(side=tk.LEFT, padx=2)

        tk.Label(self.control_frame, text="Cols:").pack(side=tk.LEFT)
        self.cols_entry = tk.Entry(self.control_frame, width=5)
        self.cols_entry.pack(side=tk.LEFT, padx=2)

        self.set_button = tk.Button(self.control_frame, text="Set Size", command=self.set_size)
        self.set_button.pack(side=tk.LEFT, padx=5)

        # Grid container
        self.grid_frame = tk.Frame(root)
        self.grid_frame.pack(pady=5)

        self.min_row = self.min_col = -1
        self.max_row = self.max_col = 1

        # Flag to track the first click
        self.first_click = True

        self.render_grid()

    def render_grid(self):
        for row in range(self.min_row, self.max_row + 1):
            for col in range(self.min_col, self.max_col + 1):
                if (row, col) not in self.grid:
                    btn = tk.Button(self.grid_frame,
                                    command=lambda r=row, c=col: self.on_click(r, c))
                    btn.config(width=self.button_pixel_size[0] // 7,
                               height=self.button_pixel_size[1] // 15)
                    if self.first_click:
                        if row != 0 or col != 0:
                            btn.config(state=tk.DISABLED)  # Disable all buttons except the center one
                    self.grid[(row, col)] = btn

        self.update_layout()

    def update_layout(self):
        for widget in self.grid_frame.winfo_children():
            widget.grid_forget()

        rows = self.max_row - self.min_row + 1
        cols = self.max_col - self.min_col + 1

        for r in range(rows):
            self.grid_frame.rowconfigure(r, weight=1)
        for c in range(cols):
            self.grid_frame.columnconfigure(c, weight=1)

        for (r, c), btn in self.grid.items():
            grid_r = r - self.min_row
            grid_c = c - self.min_col
            btn.grid(row=grid_r, column=grid_c, padx=2, pady=2, sticky="nsew")

    def on_click(self, row, col):
        if self.first_click:
            self.first_click = False
            # After the first click, enable all buttons again
            for btn in self.grid.values():
                btn.config(state=tk.NORMAL)

        self.save_state()

        btn = self.grid[(row, col)]
        btn.config(bg=self.clicked_color)

        # Load and resize image to fixed pixel size
        if os.path.exists(self.image_path):
            width, height = self.button_pixel_size
            img = Image.open(self.image_path)
            img = img.resize((width, height), Image.Resampling.LANCZOS)
            tk_img = ImageTk.PhotoImage(img)
            self.image_cache[(row, col)] = tk_img
            btn.config(image=tk_img, compound="center", text="")

        # Determine if expansion is needed
        rows = list(range(self.min_row, self.max_row + 1))
        cols = list(range(self.min_col, self.max_col + 1))
        center_row = rows[len(rows) // 2]
        center_col = cols[len(cols) // 2]

        changed = False
        if row == self.min_row:
            self.min_row -= 1
            changed = True
        if row == self.max_row:
            self.max_row += 1
            changed = True
        if col == self.min_col:
            self.min_col -= 1
            changed = True
        if col == self.max_col:
            self.max_col += 1
            changed = True

        if changed:
            self.render_grid()

    def save_state(self):
        # Save current full state
        state = {
            'min_row': self.min_row,
            'max_row': self.max_row,
            'min_col': self.min_col,
            'max_col': self.max_col,
            'button_states': {},
        }

        for (row, col), btn in self.grid.items():
            state['button_states'][(row, col)] = {
                'bg': btn.cget('bg'),
                'image': self.image_cache.get((row, col), None)
            }

        # Deepcopy the image cache refs
        state['image_cache'] = dict(self.image_cache)
        self.history.append(state)

    def restore_state(self, state):
        # Destroy all current buttons
        for btn in self.grid.values():
            btn.destroy()

        self.grid.clear()
        self.image_cache.clear()

        self.min_row = state['min_row']
        self.max_row = state['max_row']
        self.min_col = state['min_col']
        self.max_col = state['max_col']
        self.image_cache = dict(state['image_cache'])

        for (row, col), data in state['button_states'].items():
            btn = tk.Button(self.grid_frame,
                            command=lambda r=row, c=col: self.on_click(r, c))
            btn.config(width=self.button_pixel_size[0] // 7,
                       height=self.button_pixel_size[1] // 15,
                       bg=data['bg'])
            if data['image']:
                btn.config(image=data['image'], compound="center", text="")
            self.grid[(row, col)] = btn

        self.update_layout()

    def undo(self):
        if not self.history:
            return
        last_state = self.history.pop()
        self.restore_state(last_state)

    def reset_grid(self):
        for btn in self.grid.values():
            btn.destroy()
        self.grid.clear()
        self.image_cache.clear()
        self.history.clear()

        self.min_row = self.min_col = -1
        self.max_row = self.max_col = 1

        self.first_click = True  # Reset the first click flag
        self.render_grid()

    def set_size(self):
        try:
            rows = int(self.rows_entry.get())
            cols = int(self.cols_entry.get())
            if rows < 1 or cols < 1:
                raise ValueError

            self.history.clear()
            half_r = rows // 2
            half_c = cols // 2
            self.min_row = -half_r
            self.max_row = self.min_row + rows - 1
            self.min_col = -half_c
            self.max_col = self.min_col + cols - 1

            for btn in self.grid.values():
                btn.destroy()
            self.grid.clear()
            self.image_cache.clear()
            self.render_grid()
        except ValueError:
            messagebox.showerror("Invalid input", "Please enter positive integers for rows and columns.")


if __name__ == "__main__":
    root = tk.Tk()
    app = Main(root)
    root.mainloop()














#     from .constants import APP_TITLE, MAPS_VIEW_TITLE
# import tkinter as tk
# from tkinter import ttk
# from enum import Enum
# from tkinter import PhotoImage
# from PIL import Image, ImageTk
# import os

# class ButtonType(Enum):
#     START = "start"
#     COL = "col"
#     ROW = "row"

# class MapView:
#     def __init__(self, root, go_back_callback=None):
#         self.root = root
#         root.title(f"{APP_TITLE} - {MAPS_VIEW_TITLE}")

#         # Set initial window size (e.g., 400x300) and minimum size (e.g., 400x300)
#         self.min_width = 400
#         self.min_height = 300
#         self.root.geometry(f"{self.min_width}x{self.min_height}")  # Explicit starting size
#         self.max_height = 600  # Maximum height before enabling scroll
#         self.root.minsize(self.min_width, self.min_height)  # Minimum size to prevent shrinking below content

#         # Create a canvas and a vertical scrollbar
#         self.canvas = tk.Canvas(root)
#         self.scrollbar = tk.Scrollbar(root, orient="vertical", command=self.canvas.yview)
#         self.canvas.configure(yscrollcommand=self.scrollbar.set)
#         self.max_height = 800
#         self.canvas.config(height=self.max_height)  # prevent canvas from growing vertically
#         self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)       # Windows and macOS
#         self.canvas.bind_all("<Button-4>", self._on_mousewheel)         # Linux scroll up
#         self.canvas.bind_all("<Button-5>", self._on_mousewheel)         # Linux scroll down


#         # Create a frame for content
#         self.content_frame = ttk.Frame(self.canvas, padding=0)

#         # Add content frame to canvas
#         self.canvas.create_window((0, 0), window=self.content_frame, anchor="nw")

#         # Place canvas and scrollbar in root window
#         self.canvas.pack(side="left", fill="both", expand=True)
#         self.scrollbar.pack(side="right", fill="y")

#         self.button_pixel_size = (80, 80)

#         style = ttk.Style()
#         style.configure("Zigzag.TButton", font=("Helvetica", 12), padding=5)

#         self.grid = []
#         self.rows = 0
#         self.cols = 0

#         self.buttons = {}
#         self._init_buttons()
#         self.render_buttons()

#         # Update canvas scroll region and check window size
#         self.canvas.update_idletasks()
#         # self._update_window_size()

#         # Bind the canvas resizing event to the update_scroll_region method
#         self.content_frame.bind("<Configure>", self.update_scroll_region)

#     def update_scroll_region(self, event):
#         self.canvas.configure(scrollregion=self.canvas.bbox("all"))
#         # Enable or disable scrollbar based on height of the content
#         content_height = self.canvas.bbox("all")[3]  # bottom-most y-coordinate
#         if content_height > self.max_height:
#             self.scrollbar.pack(side="right", fill="y")
#         else:
#             self.scrollbar.pack_forget()
#     def _on_mousewheel(self, event):
#         if event.num == 4:  # Linux scroll up
#             self.canvas.yview_scroll(-1, "units")
#         elif event.num == 5:  # Linux scroll down
#             self.canvas.yview_scroll(1, "units")
#         else:  # Windows and macOS
#             direction = -1 if event.delta > 0 else 1
#             self.canvas.yview_scroll(direction, "units")
#     def _update_window_size(self):
#         self.root.update_idletasks()
#         width = max(self.content_frame.winfo_reqwidth(), self.min_width)
#         height = min(max(self.content_frame.winfo_reqheight(), self.min_height), self.max_height)


#         # Set window size, and lock horizontal resizing by using minsize
#         self.root.geometry(f"{width}x{height}")
#         self.root.minsize(width, 0)  # lock min width to content
#         self.root.maxsize(self.root.winfo_screenwidth(), self.max_height)  # lock max width as well (optional)

#     def on_click(self):
#         print("Button clicked!")

#     def _init_buttons(self):
#         self.buttons = {
#             ButtonType.START: {"display": True, "fn": self._render_start_button, "button": None},
#             ButtonType.COL: {"display": False, "fn": self._render_next_col_button, "button": None},
#             ButtonType.ROW: {"display": False, "fn": self._render_next_row_button, "button": None},
#         }

#     def render_buttons(self):
#         for key, value in self.buttons.items():
#             display = value.get("display", False)
#             if display:
#                 if value["button"] is None:
#                     value["fn"]()
#                 if display == "right":
#                     self.buttons[key]["button"].grid(row=self.rows - 1, column=len(self.grid[-1]))
#                 elif display == "left":
#                     col = next((i for i, x in enumerate(self.grid[-1]) if x is not None), 0) - 1
#                     self.buttons[key]["button"].grid(row=self.rows - 1, column=col)
#                 else:
#                     if self.rows % 2:
#                         self.buttons[key]["button"].grid(row=self.rows, column=self.cols - 1)
#                     else:
#                         self.buttons[key]["button"].grid(row=self.rows, column=0)
#             else:
#                 self._destroy_button(key)

#     def _destroy_button(self, key):
#         button = self.buttons[key].get("button")
#         if button:
#             button.destroy()
#             self.buttons[key]["button"] = None

#     def _make_grid_button(self, text, command):
#         return tk.Button(
#             self.content_frame,
#             text=text,
#             command=command,
#             width=self.button_pixel_size[0] // 7,
#             height=self.button_pixel_size[1] // 15,
#             font=("Helvetica", 18),
#             bg="#cccccc",
#             borderwidth=0,
#             highlightthickness=0,
#         )

#     def _make_plus_button(self, text, command):
#         return tk.Button(
#             self.content_frame,
#             text=text,
#             command=command,
#             width=self.button_pixel_size[0] // 7,
#             height=self.button_pixel_size[1] // 15,
#             font=("Helvetica", 18),
#             borderwidth=0,
#             highlightthickness=0,
#         )

#     def _render_start_button(self):
#         button =  ttk.Button(
#             self.content_frame,
#             text="Comenzar",
#             command=lambda: (self.scan(0, 0), self.add_cell()),
#             style="Zigzag.TButton"
#         )
#         button.grid(row=0, column=0)
#         self.buttons[ButtonType.START]["button"] = button

#     def _render_next_col_button(self):
#         button = self._make_plus_button("+", self.add_cell)
#         self.buttons[ButtonType.COL]["button"] = button

#     def _render_next_row_button(self):
#         button = self._make_plus_button("+", lambda: self.add_cell(row=True))
#         self.buttons[ButtonType.ROW]["button"] = button

#     def scan(self, row, col):
#         print(f"Scan at: ({row}, {col})")

#     def add_cell(self, row=False):
#         button = self._make_grid_button("", None)
#         if not self.grid:  # Initial cell
#             self.buttons[ButtonType.START]["display"] = False
#             self.buttons[ButtonType.COL]["display"] = "right"
#             self.grid.append([button])
#         elif len(self.grid) == 1:
#             if len(self.grid[0]) > 1 and row:
#                 self.buttons[ButtonType.ROW]["display"] = False
#                 self.buttons[ButtonType.COL]["display"] = "left"
#                 self.grid.append([None] * len(self.grid[0]))
#                 self.grid[-1][-1] = button
#             else:
#                 self.buttons[ButtonType.ROW]["display"] = True
#                 self.grid[0].append(button)
#         elif not len(self.grid) % 2:
#             for index in reversed(range(len(self.grid[-1]))):
#                 if self.grid[-1][index] is None:
#                     if index == 0:
#                         self.buttons[ButtonType.ROW]["display"] = True
#                         self.buttons[ButtonType.COL]["display"] = False
#                     self.grid[-1][index] = button
#                     break
#                 elif index == 0:
#                     self.buttons[ButtonType.ROW]["display"] = False
#                     self.buttons[ButtonType.COL]["display"] = "right"
#                     self.grid.append([button])
#         else:
#             if len(self.grid[-1]) == len(self.grid[0]):
#                 self.buttons[ButtonType.ROW]["display"] = False
#                 self.buttons[ButtonType.COL]["display"] = "left"
#                 self.grid.append([None] * len(self.grid[0]))
#                 self.grid[-1][-1] = button
#             else:
#                 if len(self.grid[-1]) == len(self.grid[0]) - 1:
#                     self.buttons[ButtonType.ROW]["display"] = True
#                     self.buttons[ButtonType.COL]["display"] = False
#                 self.grid[-1].append(button)

#         for r, row_items in enumerate(self.grid):
#             for c, btn in enumerate(row_items):
#                 if isinstance(btn, tk.Button):
#                     btn.configure(text=f"{self._row_letter(r)}, {c}")
#                     btn.configure(command=self._make_callback(r, c))
#                     btn.grid(row=r, column=c)

#         self.rows = len(self.grid)
#         self.cols = max(len(row) for row in self.grid)
#         self.render_buttons()
#         self._update_window_size()

#     def _make_callback(self, r, c):
#         return lambda: self.scan(r, c)

#     @staticmethod
#     def _row_letter(n):
#         result = ''
#         while n >= 0:
#             result = chr(n % 26 + ord('A')) + result
#             n = n // 26 - 1
#         return result

























# from .constants import APP_TITLE, MAPS_VIEW_TITLE
# import tkinter as tk
# from tkinter import ttk
# from enum import Enum
# from tkinter import PhotoImage
# from PIL import Image, ImageTk
# import os

# class ButtonType(Enum):
#     START = "start"
#     COL = "col"
#     ROW = "row"

# class MapView:
#     def __init__(self, root, go_back_callback=None):
#         self.root = root
#         root.title(f"{APP_TITLE} - {MAPS_VIEW_TITLE}")

#         # Set initial window size (e.g., 400x300) and minimum size (e.g., 400x300)
#         self.root.geometry("400x300")  # Explicit starting size
#         # self.root.minsize(400, 300)  # Minimum size to prevent shrinking below content

#         self.center_frame = ttk.Frame(root, padding=0)
#         self.center_frame.pack(expand=True, anchor="center")
#         # self.canvas.create_window((0, 0), window=self.center_frame, anchor="nw")
#         # self.center_frame.bind("<Configure>", self.update_scroll_region)

#         self.button_pixel_size = (80, 80)

#         style = ttk.Style()
#         style.configure("Zigzag.TButton", font=("Helvetica", 12), padding=5)

#         self.grid = []
#         self.rows = 0
#         self.cols = 0

#         self.buttons = {}
#         self._init_buttons()
#         self.render_buttons()

#         root.update_idletasks()  # Force geometry update

#     # Function to update the scroll region when the content changes
#     def update_scroll_region(event):
#         self.canvas.configure(scrollregion=self.canvas.bbox("all"))

#     def _update_window_size(self):
#         self.root.update_idletasks()  # Ensure layout is updated
#         width = self.center_frame.winfo_reqwidth()
#         height = self.center_frame.winfo_reqheight()
#         # self.root.geometry(f"{width}x{height}")  # Set to exact size
#         self.root.minsize(width, height)  # Prevent shrinking below content

#     def on_click(self):
#         print("Button clicked!")

#     def _init_buttons(self):
#         self.buttons = {
#             ButtonType.START: {"display": True, "fn": self._render_start_button, "button": None},
#             ButtonType.COL: {"display": False, "fn": self._render_next_col_button, "button": None},
#             ButtonType.ROW: {"display": False, "fn": self._render_next_row_button, "button": None},
#         }

#     def render_buttons(self):
#         for key, value in self.buttons.items():
#             display = value.get("display", False)
#             if display:
#                 if value["button"] is None:
#                     value["fn"]()
#                 if display == "right":
#                     self.buttons[key]["button"].grid(row=self.rows - 1, column=len(self.grid[-1]))
#                 elif display == "left":
#                     col = next((i for i, x in enumerate(self.grid[-1]) if x is not None), 0) - 1
#                     self.buttons[key]["button"].grid(row=self.rows - 1, column=col)
#                 else:
#                     if self.rows % 2:
#                         self.buttons[key]["button"].grid(row=self.rows, column=self.cols - 1)
#                     else:
#                         self.buttons[key]["button"].grid(row=self.rows, column=0)
#             else:
#                 self._destroy_button(key)

#     def _destroy_button(self, key):
#         button = self.buttons[key].get("button")
#         if button:
#             button.destroy()
#             self.buttons[key]["button"] = None

#     def _make_grid_button(self, text, command):
#         return tk.Button(
#             self.center_frame,
#             text=text,
#             command=command,
#             width=self.button_pixel_size[0] // 7,
#             height=self.button_pixel_size[1] // 15,
#             font=("Helvetica", 18),
#             bg="#cccccc",
#             borderwidth=0,
#             highlightthickness=0,
#         )

#     def _make_plus_button(self, text, command):
#         # img_boton = tk.PhotoImage(file="assets/button.png")
#         # boton = ttk.Button(self.center_frame,width=self.button_pixel_size[0] // 7,image=img_boton)
#         # boton.place(x=50, y=50)
#         # return boton
#         return tk.Button(
#             self.center_frame,
#             text=text,
#             command=command,
#             width=self.button_pixel_size[0] // 7,
#             height=self.button_pixel_size[1] // 15,
#             font=("Helvetica", 18),
#             borderwidth=0,
#             highlightthickness=0,
#         )

#     def _render_start_button(self):
#         button =  ttk.Button(
#             self.center_frame,
#             text="Comenzar",
#             command=lambda: (self.scan(0, 0), self.add_cell()),
#             style="Zigzag.TButton"
#         )
#         button.grid(row=0, column=0)
#         self.buttons[ButtonType.START]["button"] = button

#     def _render_next_col_button(self):
#         button = self._make_plus_button("+", self.add_cell)
#         self.buttons[ButtonType.COL]["button"] = button

#     def _render_next_row_button(self):
#         button = self._make_plus_button("+", lambda: self.add_cell(row=True))
#         self.buttons[ButtonType.ROW]["button"] = button

#     def scan(self, row, col):
#         print(f"Scan at: ({row}, {col})")

#     def add_cell(self, row=False):
#         button = self._make_grid_button("", None)
#         if not self.grid:  # Initial cell
#             self.buttons[ButtonType.START]["display"] = False
#             self.buttons[ButtonType.COL]["display"] = "right"
#             self.grid.append([button])
#         elif len(self.grid) == 1:
#             if len(self.grid[0]) > 1 and row:
#                 self.buttons[ButtonType.ROW]["display"] = False
#                 self.buttons[ButtonType.COL]["display"] = "left"
#                 self.grid.append([None] * len(self.grid[0]))
#                 self.grid[-1][-1] = button
#             else:
#                 self.buttons[ButtonType.ROW]["display"] = True
#                 self.grid[0].append(button)
#         elif not len(self.grid) % 2:
#             for index in reversed(range(len(self.grid[-1]))):
#                 if self.grid[-1][index] is None:
#                     if index == 0:
#                         self.buttons[ButtonType.ROW]["display"] = True
#                         self.buttons[ButtonType.COL]["display"] = False
#                     self.grid[-1][index] = button
#                     break
#                 elif index == 0:
#                     self.buttons[ButtonType.ROW]["display"] = False
#                     self.buttons[ButtonType.COL]["display"] = "right"
#                     self.grid.append([button])
#         else:
#             if len(self.grid[-1]) == len(self.grid[0]):
#                 self.buttons[ButtonType.ROW]["display"] = False
#                 self.buttons[ButtonType.COL]["display"] = "left"
#                 self.grid.append([None] * len(self.grid[0]))
#                 self.grid[-1][-1] = button
#             else:
#                 if len(self.grid[-1]) == len(self.grid[0]) - 1:
#                     self.buttons[ButtonType.ROW]["display"] = True
#                     self.buttons[ButtonType.COL]["display"] = False
#                 self.grid[-1].append(button)

#         for r, row_items in enumerate(self.grid):
#             for c, btn in enumerate(row_items):
#                 if isinstance(btn, tk.Button):
#                     btn.configure(text=f"{self._row_letter(r)}, {c}")
#                     btn.configure(command=self._make_callback(r, c))
#                     btn.grid(row=r, column=c)

#         self.rows = len(self.grid)
#         self.cols = max(len(row) for row in self.grid)
#         self.render_buttons()
#         self._update_window_size()

#     def _make_callback(self, r, c):
#         return lambda: self.scan(r, c)

#     @staticmethod
#     def _row_letter(n):
#         result = ''
#         while n >= 0:
#             result = chr(n % 26 + ord('A')) + result
#             n = n // 26 - 1
#         return result


