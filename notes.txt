asd

        self.grid_frame = tk.Frame(root)
        self.grid_frame.pack(padx=20, pady=20)

        self.buttons = {}
        self.current_row = 0
        self.current_col = 0
        self.direction = 'right'
        self.max_col = None  # None means column limit isn't locked yet

        self.add_button(self.current_row, self.current_col)

    def add_button(self, row, col):
        if (row, col) not in self.buttons:
            btn = tk.Button(
                self.grid_frame,
                text=f"{row},{col}",
                command=lambda r=row, c=col: self.on_button_click(r, c)
            )
            btn.grid(row=row, column=col, padx=5, pady=5)
            self.buttons[(row, col)] = btn

    def on_button_click(self, row, col):
        if row != self.current_row or col != self.current_col:
            return  # Only allow clicks on the current endpoint button

        if self.max_col is None:
            # Still building first row freely to the right
            self.current_col += 1
            self.add_button(self.current_row, self.current_col)
        else:
            if self.direction == 'right':
                if self.current_col < self.max_col:
                    self.current_col += 1
                    self.add_button(self.current_row, self.current_col)
                else:
                    self.current_row += 1
                    self.add_button(self.current_row, self.current_col)
                    self.direction = 'left'
            else:  # direction == 'left'
                if self.current_col > 0:
                    self.current_col -= 1
                    self.add_button(self.current_row, self.current_col)
                else:
                    self.current_row += 1
                    self.add_button(self.current_row, self.current_col)
                    self.direction = 'right'

        # If we’ve gone down for the first time, lock max_col
        if self.max_col is None and self.current_row > 0:
            self.max_col = self.current_col

        self.canvas_size = 800
        self.square_size = 50
        self.offset = self.canvas_size // 2

        self.canvas = tk.Canvas(root, width=self.canvas_size, height=self.canvas_size, bg='white')
        self.canvas.pack()

        self.positions = set()
        self.min_x = self.max_x = 0
        self.min_y = self.max_y = 0

        self.draw_square(0, 0)
        self.draw_arrows()

    def grid_to_canvas(self, x, y):
        """Convert grid coords to canvas pixel coords (top-left)."""
        left = self.offset + x * self.square_size
        top = self.offset + y * self.square_size
        return left, top

    def draw_square(self, x, y):
        left, top = self.grid_to_canvas(x, y)
        right = left + self.square_size
        bottom = top + self.square_size
        self.canvas.create_rectangle(left, top, right, bottom, fill='skyblue', outline='black')
        self.positions.add((x, y))
        self.min_x = min(self.min_x, x)
        self.max_x = max(self.max_x, x)
        self.min_y = min(self.min_y, y)
        self.max_y = max(self.max_y, y)

    def draw_arrows(self):
        # Remove old arrows
        for tag in self.canvas.find_withtag("arrow"):
            self.canvas.delete(tag)

        # Horizontal expansion arrows (top and bottom)
        for x in range(self.min_x, self.max_x + 1):
            if (x, self.min_y - 1) not in self.positions:
                self.create_arrow_button("↑", x, self.min_y - 1, 0, -1)
            if (x, self.max_y + 1) not in self.positions:
                self.create_arrow_button("↓", x, self.max_y + 1, 0, 1)

        # Vertical expansion arrows (left and right)
        for y in range(self.min_y, self.max_y + 1):
            if (self.min_x - 1, y) not in self.positions:
                self.create_arrow_button("←", self.min_x - 1, y, -1, 0)
            if (self.max_x + 1, y) not in self.positions:
                self.create_arrow_button("→", self.max_x + 1, y, 1, 0)

    def create_arrow_button(self, symbol, grid_x, grid_y, dx, dy):
        """Create a styled arrow button at the specified grid position."""
        bx, by = self.grid_to_canvas(grid_x, grid_y)
        button = tk.Button(
            self.root, text=symbol,
            font=("Arial", 14, "bold"),
            width=2, height=1,
            bg="lightgray", relief="raised",
            command=lambda: self.add_square(grid_x, grid_y)
        )
        self.canvas.create_window(
            bx + self.square_size // 2,
            by + self.square_size // 2,
            window=button,
            tags="arrow"
        )

    def add_square(self, x, y):
        if (x, y) not in self.positions:
            self.draw_square(x, y)
            self.draw_arrows()




        self.clicked_color = "lightblue"
        self.default_color = "SystemButtonFace"
        self.grid = {}  # {(row, col): button}
        self.image_cache = {}  # Prevent garbage collection

        self.image_path = os.path.join(os.path.dirname(__file__), "test.png")
        self.button_pixel_size = (100, 100)

        # History of full states
        self.history = []

        # Control panel
        self.control_frame = tk.Frame(root)
        self.control_frame.pack(pady=5)

        self.reset_button = tk.Button(self.control_frame, text="Reset", command=self.reset_grid)
        self.reset_button.pack(side=tk.LEFT, padx=5)

        self.undo_button = tk.Button(self.control_frame, text="Undo", command=self.undo)
        self.undo_button.pack(side=tk.LEFT, padx=5)

        tk.Label(self.control_frame, text="Rows:").pack(side=tk.LEFT)
        self.rows_entry = tk.Entry(self.control_frame, width=5)
        self.rows_entry.pack(side=tk.LEFT, padx=2)

        tk.Label(self.control_frame, text="Cols:").pack(side=tk.LEFT)
        self.cols_entry = tk.Entry(self.control_frame, width=5)
        self.cols_entry.pack(side=tk.LEFT, padx=2)

        self.set_button = tk.Button(self.control_frame, text="Set Size", command=self.set_size)
        self.set_button.pack(side=tk.LEFT, padx=5)

        # Grid container
        self.grid_frame = tk.Frame(root)
        self.grid_frame.pack(pady=5)

        self.min_row = self.min_col = -1
        self.max_row = self.max_col = 1

        self.render_grid()

    def render_grid(self):
        for row in range(self.min_row, self.max_row + 1):
            for col in range(self.min_col, self.max_col + 1):
                if (row, col) not in self.grid:
                    btn = tk.Button(self.grid_frame,
                                    command=lambda r=row, c=col: self.on_click(r, c))
                    btn.config(width=self.button_pixel_size[0] // 7,
                               height=self.button_pixel_size[1] // 15)
                    self.grid[(row, col)] = btn

        self.update_layout()

    def update_layout(self):
        for widget in self.grid_frame.winfo_children():
            widget.grid_forget()

        rows = self.max_row - self.min_row + 1
        cols = self.max_col - self.min_col + 1

        for r in range(rows):
            self.grid_frame.rowconfigure(r, weight=1)
        for c in range(cols):
            self.grid_frame.columnconfigure(c, weight=1)

        for (r, c), btn in self.grid.items():
            grid_r = r - self.min_row
            grid_c = c - self.min_col
            btn.grid(row=grid_r, column=grid_c, padx=2, pady=2, sticky="nsew")

    def on_click(self, row, col):
        self.save_state()

        btn = self.grid[(row, col)]
        btn.config(bg=self.clicked_color)

        # Load and resize image to fixed pixel size
        if os.path.exists(self.image_path):
            width, height = self.button_pixel_size
            img = Image.open(self.image_path)
            img = img.resize((width, height), Image.Resampling.LANCZOS)
            tk_img = ImageTk.PhotoImage(img)
            self.image_cache[(row, col)] = tk_img
            btn.config(image=tk_img, compound="center", text="")

        # Determine if expansion is needed
        rows = list(range(self.min_row, self.max_row + 1))
        cols = list(range(self.min_col, self.max_col + 1))
        center_row = rows[len(rows) // 2]
        center_col = cols[len(cols) // 2]

        changed = False
        if row == self.min_row:
            self.min_row -= 1
            changed = True
        if row == self.max_row:
            self.max_row += 1
            changed = True
        if col == self.min_col:
            self.min_col -= 1
            changed = True
        if col == self.max_col:
            self.max_col += 1
            changed = True

        if changed:
            self.render_grid()

    def save_state(self):
        # Save current full state
        state = {
            'min_row': self.min_row,
            'max_row': self.max_row,
            'min_col': self.min_col,
            'max_col': self.max_col,
            'button_states': {},
        }

        for (row, col), btn in self.grid.items():
            state['button_states'][(row, col)] = {
                'bg': btn.cget('bg'),
                'image': self.image_cache.get((row, col), None)
            }

        # Deepcopy the image cache refs
        state['image_cache'] = dict(self.image_cache)
        self.history.append(state)

    def restore_state(self, state):
        # Destroy all current buttons
        for btn in self.grid.values():
            btn.destroy()

        self.grid.clear()
        self.image_cache.clear()

        self.min_row = state['min_row']
        self.max_row = state['max_row']
        self.min_col = state['min_col']
        self.max_col = state['max_col']
        self.image_cache = dict(state['image_cache'])

        for (row, col), data in state['button_states'].items():
            btn = tk.Button(self.grid_frame,
                            command=lambda r=row, c=col: self.on_click(r, c))
            btn.config(width=self.button_pixel_size[0] // 7,
                       height=self.button_pixel_size[1] // 15,
                       bg=data['bg'])
            if data['image']:
                btn.config(image=data['image'], compound="center", text="")
            self.grid[(row, col)] = btn

        self.update_layout()

    def undo(self):
        if not self.history:
            return
        last_state = self.history.pop()
        self.restore_state(last_state)

    def reset_grid(self):
        for btn in self.grid.values():
            btn.destroy()
        self.grid.clear()
        self.image_cache.clear()
        self.history.clear()

        self.min_row = self.min_col = -1
        self.max_row = self.max_col = 1

        self.render_grid()

    def set_size(self):
        try:
            rows = int(self.rows_entry.get())
            cols = int(self.cols_entry.get())
            if rows < 1 or cols < 1:
                raise ValueError

            self.history.clear()
            half_r = rows // 2
            half_c = cols // 2
            self.min_row = -half_r
            self.max_row = self.min_row + rows - 1
            self.min_col = -half_c
            self.max_col = self.min_col + cols - 1

            for btn in self.grid.values():
                btn.destroy()
            self.grid.clear()
            self.image_cache.clear()
            self.render_grid()
        except ValueError:
            messagebox.showerror("Invalid input", "Please enter positive integers for rows and columns.")











        self.clicked_color = "lightblue"
        self.default_color = "SystemButtonFace"
        self.grid = {}  # {(row, col): button}
        self.image_cache = {}  # Prevent garbage collection

        self.image_path = os.path.join(os.path.dirname(__file__), "test.png")
        self.button_pixel_size = (100, 100)

        # History of full states
        self.history = []

        # Control panel
        self.control_frame = tk.Frame(root)
        self.control_frame.pack(pady=5)

        self.reset_button = tk.Button(self.control_frame, text="Reset", command=self.reset_grid)
        self.reset_button.pack(side=tk.LEFT, padx=5)

        self.undo_button = tk.Button(self.control_frame, text="Undo", command=self.undo)
        self.undo_button.pack(side=tk.LEFT, padx=5)

        tk.Label(self.control_frame, text="Rows:").pack(side=tk.LEFT)
        self.rows_entry = tk.Entry(self.control_frame, width=5)
        self.rows_entry.pack(side=tk.LEFT, padx=2)

        tk.Label(self.control_frame, text="Cols:").pack(side=tk.LEFT)
        self.cols_entry = tk.Entry(self.control_frame, width=5)
        self.cols_entry.pack(side=tk.LEFT, padx=2)

        self.set_button = tk.Button(self.control_frame, text="Set Size", command=self.set_size)
        self.set_button.pack(side=tk.LEFT, padx=5)

        # Grid container
        self.grid_frame = tk.Frame(root)
        self.grid_frame.pack(pady=5)

        self.min_row = self.min_col = -1
        self.max_row = self.max_col = 1

        # Flag to track the first click
        self.first_click = True

        self.render_grid()

    def render_grid(self):
        for row in range(self.min_row, self.max_row + 1):
            for col in range(self.min_col, self.max_col + 1):
                if (row, col) not in self.grid:
                    btn = tk.Button(self.grid_frame,
                                    command=lambda r=row, c=col: self.on_click(r, c))
                    btn.config(width=self.button_pixel_size[0] // 7,
                               height=self.button_pixel_size[1] // 15)
                    if self.first_click:
                        if row != 0 or col != 0:
                            btn.config(state=tk.DISABLED)  # Disable all buttons except the center one
                    self.grid[(row, col)] = btn

        self.update_layout()

    def update_layout(self):
        for widget in self.grid_frame.winfo_children():
            widget.grid_forget()

        rows = self.max_row - self.min_row + 1
        cols = self.max_col - self.min_col + 1

        for r in range(rows):
            self.grid_frame.rowconfigure(r, weight=1)
        for c in range(cols):
            self.grid_frame.columnconfigure(c, weight=1)

        for (r, c), btn in self.grid.items():
            grid_r = r - self.min_row
            grid_c = c - self.min_col
            btn.grid(row=grid_r, column=grid_c, padx=2, pady=2, sticky="nsew")

    def on_click(self, row, col):
        if self.first_click:
            self.first_click = False
            # After the first click, enable all buttons again
            for btn in self.grid.values():
                btn.config(state=tk.NORMAL)

        self.save_state()

        btn = self.grid[(row, col)]
        btn.config(bg=self.clicked_color)

        # Load and resize image to fixed pixel size
        if os.path.exists(self.image_path):
            width, height = self.button_pixel_size
            img = Image.open(self.image_path)
            img = img.resize((width, height), Image.Resampling.LANCZOS)
            tk_img = ImageTk.PhotoImage(img)
            self.image_cache[(row, col)] = tk_img
            btn.config(image=tk_img, compound="center", text="")

        # Determine if expansion is needed
        rows = list(range(self.min_row, self.max_row + 1))
        cols = list(range(self.min_col, self.max_col + 1))
        center_row = rows[len(rows) // 2]
        center_col = cols[len(cols) // 2]

        changed = False
        if row == self.min_row:
            self.min_row -= 1
            changed = True
        if row == self.max_row:
            self.max_row += 1
            changed = True
        if col == self.min_col:
            self.min_col -= 1
            changed = True
        if col == self.max_col:
            self.max_col += 1
            changed = True

        if changed:
            self.render_grid()

    def save_state(self):
        # Save current full state
        state = {
            'min_row': self.min_row,
            'max_row': self.max_row,
            'min_col': self.min_col,
            'max_col': self.max_col,
            'button_states': {},
        }

        for (row, col), btn in self.grid.items():
            state['button_states'][(row, col)] = {
                'bg': btn.cget('bg'),
                'image': self.image_cache.get((row, col), None)
            }

        # Deepcopy the image cache refs
        state['image_cache'] = dict(self.image_cache)
        self.history.append(state)

    def restore_state(self, state):
        # Destroy all current buttons
        for btn in self.grid.values():
            btn.destroy()

        self.grid.clear()
        self.image_cache.clear()

        self.min_row = state['min_row']
        self.max_row = state['max_row']
        self.min_col = state['min_col']
        self.max_col = state['max_col']
        self.image_cache = dict(state['image_cache'])

        for (row, col), data in state['button_states'].items():
            btn = tk.Button(self.grid_frame,
                            command=lambda r=row, c=col: self.on_click(r, c))
            btn.config(width=self.button_pixel_size[0] // 7,
                       height=self.button_pixel_size[1] // 15,
                       bg=data['bg'])
            if data['image']:
                btn.config(image=data['image'], compound="center", text="")
            self.grid[(row, col)] = btn

        self.update_layout()

    def undo(self):
        if not self.history:
            return
        last_state = self.history.pop()
        self.restore_state(last_state)

    def reset_grid(self):
        for btn in self.grid.values():
            btn.destroy()
        self.grid.clear()
        self.image_cache.clear()
        self.history.clear()

        self.min_row = self.min_col = -1
        self.max_row = self.max_col = 1

        self.first_click = True  # Reset the first click flag
        self.render_grid()

    def set_size(self):
        try:
            rows = int(self.rows_entry.get())
            cols = int(self.cols_entry.get())
            if rows < 1 or cols < 1:
                raise ValueError

            self.history.clear()
            half_r = rows // 2
            half_c = cols // 2
            self.min_row = -half_r
            self.max_row = self.min_row + rows - 1
            self.min_col = -half_c
            self.max_col = self.min_col + cols - 1

            for btn in self.grid.values():
                btn.destroy()
            self.grid.clear()
            self.image_cache.clear()
            self.render_grid()
        except ValueError:
            messagebox.showerror("Invalid input", "Please enter positive integers for rows and columns.")
